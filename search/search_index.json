{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pypapermerge A python papermerge api client This client is still a work in progress and only very few API endpoints have been implemented. Please see the currently implemented endpoints here .","title":"Index"},{"location":"#welcome-to-pypapermerge","text":"","title":"Welcome to pypapermerge"},{"location":"#a-python-papermerge-api-client","text":"This client is still a work in progress and only very few API endpoints have been implemented. Please see the currently implemented endpoints here .","title":"A python papermerge api client"},{"location":"reference/SUMMARY/","text":"","title":"Code Reference"},{"location":"reference/pypapermerge/","text":"pypapermerge python API client for papermerge. Modules exported by this package: api : Provides external functions related to the api tools : Provides internal functions to the api","title":"Pypapermerge"},{"location":"reference/pypapermerge/api/","text":"Provides an entrypoint to the endpoints for the api client. The module contains the following functions: endpoint() - Returns the api endpoint URL create_token(username, password) - Creates an API token and returns the requests reponse Api Main Class everything branches off of Source code in pypapermerge/api.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Api : \"\"\"Main Class everything branches off of\"\"\" def __init__ ( self , url : str , token : str | None = None ): logger . trace ( f \"URL is: { url } \" ) self . apiurl = f ' { url if url [ - 1 ] != \"/\" else url [: - 1 ] } /api' self . token = token self . documents = Documents ( self ) self . nodes = Nodes ( self ) def endpoint ( self ) -> str : \"\"\"Returns the api endpoint URL\"\"\" api_url = self . apiurl return api_url def create_token ( self , username : str , password : str ) -> requests . Response : \"\"\"Creates an API token if needed\"\"\" response = requests . post ( f \" { self . apiurl } /auth/login/\" , json = { \"username\" : username , \"password\" : password }, timeout = 5 , ) self . token = loads ( response . content . decode ())[ \"token\" ] return response create_token ( username , password ) Creates an API token if needed Source code in pypapermerge/api.py 34 35 36 37 38 39 40 41 42 43 def create_token ( self , username : str , password : str ) -> requests . Response : \"\"\"Creates an API token if needed\"\"\" response = requests . post ( f \" { self . apiurl } /auth/login/\" , json = { \"username\" : username , \"password\" : password }, timeout = 5 , ) self . token = loads ( response . content . decode ())[ \"token\" ] return response endpoint () Returns the api endpoint URL Source code in pypapermerge/api.py 29 30 31 32 def endpoint ( self ) -> str : \"\"\"Returns the api endpoint URL\"\"\" api_url = self . apiurl return api_url","title":"Api"},{"location":"reference/pypapermerge/api/#pypapermerge.api.Api","text":"Main Class everything branches off of Source code in pypapermerge/api.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Api : \"\"\"Main Class everything branches off of\"\"\" def __init__ ( self , url : str , token : str | None = None ): logger . trace ( f \"URL is: { url } \" ) self . apiurl = f ' { url if url [ - 1 ] != \"/\" else url [: - 1 ] } /api' self . token = token self . documents = Documents ( self ) self . nodes = Nodes ( self ) def endpoint ( self ) -> str : \"\"\"Returns the api endpoint URL\"\"\" api_url = self . apiurl return api_url def create_token ( self , username : str , password : str ) -> requests . Response : \"\"\"Creates an API token if needed\"\"\" response = requests . post ( f \" { self . apiurl } /auth/login/\" , json = { \"username\" : username , \"password\" : password }, timeout = 5 , ) self . token = loads ( response . content . decode ())[ \"token\" ] return response","title":"Api"},{"location":"reference/pypapermerge/api/#pypapermerge.api.Api.create_token","text":"Creates an API token if needed Source code in pypapermerge/api.py 34 35 36 37 38 39 40 41 42 43 def create_token ( self , username : str , password : str ) -> requests . Response : \"\"\"Creates an API token if needed\"\"\" response = requests . post ( f \" { self . apiurl } /auth/login/\" , json = { \"username\" : username , \"password\" : password }, timeout = 5 , ) self . token = loads ( response . content . decode ())[ \"token\" ] return response","title":"create_token()"},{"location":"reference/pypapermerge/api/#pypapermerge.api.Api.endpoint","text":"Returns the api endpoint URL Source code in pypapermerge/api.py 29 30 31 32 def endpoint ( self ) -> str : \"\"\"Returns the api endpoint URL\"\"\" api_url = self . apiurl return api_url","title":"endpoint()"},{"location":"reference/pypapermerge/tools/","text":"Internal functions for the API client to use check_ctype ( content_type ) Check if the content type is either 'documents' or 'folders' Source code in pypapermerge/tools.py 8 9 10 11 12 def check_ctype ( content_type : str ) -> None : \"\"\"Check if the content type is either 'documents' or 'folders'\"\"\" valid = [ \"documents\" , \"folders\" ] if content_type not in valid : raise ValueError ( f \"_reverse_list: content_type must be one of { valid } .\" ) check_id ( idd ) Check if id given is a valid papermerge ID Source code in pypapermerge/tools.py 15 16 17 18 19 20 21 22 23 24 25 26 def check_id ( idd : str | list [ str ] | None ) -> bool : \"\"\"Check if id given is a valid papermerge ID\"\"\" callerc , callerf = whocalledme () if idd is None : raise TypeError ( f \"Received no id from { callerc } . { callerf } .\" ) if isinstance ( idd , list ): raise TypeError ( f \"Received multiple IDs from { callerc } . { callerf } . It should should only be one.\" ) if not len ( idd . split ( \"-\" )) == 5 or not len ( idd ) == 36 : # type: ignore raise ValueError ( f 'Received wrong ID \" { idd } \" from { callerc } . { callerf } .' ) return True whocalledme () Function to return the calling function+class Source code in pypapermerge/tools.py 29 30 31 32 33 34 def whocalledme () -> tuple [ str , str ]: \"\"\"Function to return the calling function+class\"\"\" stack2 = stack ()[ 2 ][ 0 ] if \"pytest\" in modules : return \"tests\" , stack2 . f_code . co_name return stack2 . f_locals [ \"self\" ] . __class__ . __name__ , stack2 . f_code . co_name","title":"Tools"},{"location":"reference/pypapermerge/tools/#pypapermerge.tools.check_ctype","text":"Check if the content type is either 'documents' or 'folders' Source code in pypapermerge/tools.py 8 9 10 11 12 def check_ctype ( content_type : str ) -> None : \"\"\"Check if the content type is either 'documents' or 'folders'\"\"\" valid = [ \"documents\" , \"folders\" ] if content_type not in valid : raise ValueError ( f \"_reverse_list: content_type must be one of { valid } .\" )","title":"check_ctype()"},{"location":"reference/pypapermerge/tools/#pypapermerge.tools.check_id","text":"Check if id given is a valid papermerge ID Source code in pypapermerge/tools.py 15 16 17 18 19 20 21 22 23 24 25 26 def check_id ( idd : str | list [ str ] | None ) -> bool : \"\"\"Check if id given is a valid papermerge ID\"\"\" callerc , callerf = whocalledme () if idd is None : raise TypeError ( f \"Received no id from { callerc } . { callerf } .\" ) if isinstance ( idd , list ): raise TypeError ( f \"Received multiple IDs from { callerc } . { callerf } . It should should only be one.\" ) if not len ( idd . split ( \"-\" )) == 5 or not len ( idd ) == 36 : # type: ignore raise ValueError ( f 'Received wrong ID \" { idd } \" from { callerc } . { callerf } .' ) return True","title":"check_id()"},{"location":"reference/pypapermerge/tools/#pypapermerge.tools.whocalledme","text":"Function to return the calling function+class Source code in pypapermerge/tools.py 29 30 31 32 33 34 def whocalledme () -> tuple [ str , str ]: \"\"\"Function to return the calling function+class\"\"\" stack2 = stack ()[ 2 ][ 0 ] if \"pytest\" in modules : return \"tests\" , stack2 . f_code . co_name return stack2 . f_locals [ \"self\" ] . __class__ . __name__ , stack2 . f_code . co_name","title":"whocalledme()"},{"location":"reference/pypapermerge/endpoints/","text":"All (implemented) endpoint modules of the papermerge API Currently implemented auth login documents document_list upload file delete documents nodes nodes_create folders groups ocr pages permissions preferences schema search tags tokens users version","title":"Endpoints"},{"location":"reference/pypapermerge/endpoints/#pypapermerge.endpoints--currently-implemented","text":"auth login documents document_list upload file delete documents nodes nodes_create folders groups ocr pages permissions preferences schema search tags tokens users version","title":"Currently implemented"},{"location":"reference/pypapermerge/endpoints/documents/","text":"Module that includes the Documents class Documents Class that implements the document endpoints Source code in pypapermerge/endpoints/documents.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class Documents : \"\"\" Class that implements the document endpoints \"\"\" def __init__ ( self , api ): # type: ignore self . api = api def all ( self ) -> dict : \"\"\" Returns all documents on the server Returns: return_dict: Key: ID of documents, Value (dict): attributes of documents \"\"\" headers = { \"Authorization\" : f \"Token { self . api . token } \" , } response = requests . get ( f \" { self . api . apiurl } /documents/\" , headers = headers , timeout = 5 ) json_content = json . loads ( response . content ) return_dict = {} for i in json_content [ \"data\" ]: return_dict . update ({ i [ \"id\" ]: i [ \"attributes\" ]}) return return_dict def id ( # pylint: disable=C0103 self , name : str , content_type : str ) -> str | list [ str ] | None : \"\"\" Returns the ID of either documents or folders type Args: name: Name of either a document or folder content_type: Can be one of \"documents\" or \"folders\", based on the type of content to id Returns: None (None): If no fitting document/folder was found return_id (str): If one fitting document/folder was found return_id (list): If multiple fitting documents/folders were found \"\"\" tools . check_ctype ( content_type ) reverse_dict = self . _reverse_list ( content_type ) if name in reverse_dict : logger . trace ( f \"ID of { name } is: { reverse_dict [ name ] } \" ) return_id = reverse_dict [ name ] if len ( return_id ) == 1 : return return_id [ 0 ] return return_id return None def upload ( self , file : str , folder : str = \".inbox\" , isid : bool = False ) -> requests . Response : \"\"\" Uploads a file to a folder. Args: file: Path to a file to be uploaded folder: Can be either a folder name or ID. isid: Bool when folder is an ID Returns: Upload response \"\"\" if not os . path . exists ( file ): raise FileNotFoundError ( f \"File { file } does not exist.\" ) file_name = os . path . basename ( file ) if self . id ( file_name , \"documents\" ): file_id = self . id ( file_name , \"documents\" ) tools . check_id ( file_id ) else : if isid : folder_id : str = folder else : folder_id = self . id ( folder , \"folders\" ) # type: ignore tools . check_id ( folder_id ) file_id = self . api . nodes . create ( file_name , \"documents\" , folder_id ) url = f \" { self . api . apiurl } /documents/ { file_id } /upload/ { file_name } \" mimetype = guess_type ( file_name )[ 1 ] headers : dict = { \"Content-Disposition\" : f \"attachment; filename= { file_name } \" , \"Content-Type\" : mimetype , \"Authorization\" : f \"Token { self . api . token } \" , } with open ( file , \"rb\" ) as fobj : response = requests . put ( url , data = fobj , headers = headers , timeout = 5 ) return response def delete ( self , idd : str ) -> bool : \"\"\" Deletes the document identified by the ID given to the function Arguments: idd: ID of the document to be deleted Returns: Either True or False, based on the success of deletion of the document \"\"\" tools . check_id ( idd ) url = f \" { self . api . apiurl } /documents/ { idd } \" headers : dict = { \"Authorization\" : f \"Token { self . api . token } \" } response = requests . delete ( url , headers = headers , timeout = 5 ) return_code = response . status_code == 204 return return_code def _reverse_list ( self , content_type : str ) -> dict : \"\"\" Returns a reversed list of all documents, in order to find the specific ID of a document if only a name is known \"\"\" tools . check_ctype ( content_type ) headers = { \"Authorization\" : f \"Token { self . api . token } \" , } if content_type == \"documents\" : url = f \" { self . api . apiurl } /documents/\" else : url = f \" { self . api . apiurl } /folders/\" response = requests . get ( url , headers = headers , timeout = 5 ) json_content = json . loads ( response . content ) reverse_dict = defaultdict ( list ) for i in json_content [ \"data\" ]: reverse_dict [ i [ \"attributes\" ][ \"title\" ]] . append ( i [ \"id\" ]) return reverse_dict all () Returns all documents on the server Returns: Name Type Description return_dict dict Key: ID of documents, Value (dict): attributes of documents Source code in pypapermerge/endpoints/documents.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def all ( self ) -> dict : \"\"\" Returns all documents on the server Returns: return_dict: Key: ID of documents, Value (dict): attributes of documents \"\"\" headers = { \"Authorization\" : f \"Token { self . api . token } \" , } response = requests . get ( f \" { self . api . apiurl } /documents/\" , headers = headers , timeout = 5 ) json_content = json . loads ( response . content ) return_dict = {} for i in json_content [ \"data\" ]: return_dict . update ({ i [ \"id\" ]: i [ \"attributes\" ]}) return return_dict delete ( idd ) Deletes the document identified by the ID given to the function Parameters: Name Type Description Default idd str ID of the document to be deleted required Returns: Type Description bool Either True or False, based on the success of deletion of the document Source code in pypapermerge/endpoints/documents.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def delete ( self , idd : str ) -> bool : \"\"\" Deletes the document identified by the ID given to the function Arguments: idd: ID of the document to be deleted Returns: Either True or False, based on the success of deletion of the document \"\"\" tools . check_id ( idd ) url = f \" { self . api . apiurl } /documents/ { idd } \" headers : dict = { \"Authorization\" : f \"Token { self . api . token } \" } response = requests . delete ( url , headers = headers , timeout = 5 ) return_code = response . status_code == 204 return return_code id ( name , content_type ) Returns the ID of either documents or folders type Parameters: Name Type Description Default name str Name of either a document or folder required content_type str Can be one of \"documents\" or \"folders\", based on the type of content to id required Returns: Name Type Description None None If no fitting document/folder was found return_id str If one fitting document/folder was found return_id list If multiple fitting documents/folders were found Source code in pypapermerge/endpoints/documents.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def id ( # pylint: disable=C0103 self , name : str , content_type : str ) -> str | list [ str ] | None : \"\"\" Returns the ID of either documents or folders type Args: name: Name of either a document or folder content_type: Can be one of \"documents\" or \"folders\", based on the type of content to id Returns: None (None): If no fitting document/folder was found return_id (str): If one fitting document/folder was found return_id (list): If multiple fitting documents/folders were found \"\"\" tools . check_ctype ( content_type ) reverse_dict = self . _reverse_list ( content_type ) if name in reverse_dict : logger . trace ( f \"ID of { name } is: { reverse_dict [ name ] } \" ) return_id = reverse_dict [ name ] if len ( return_id ) == 1 : return return_id [ 0 ] return return_id return None upload ( file , folder = '.inbox' , isid = False ) Uploads a file to a folder. Parameters: Name Type Description Default file str Path to a file to be uploaded required folder str Can be either a folder name or ID. '.inbox' isid bool Bool when folder is an ID False Returns: Type Description requests . Response Upload response Source code in pypapermerge/endpoints/documents.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def upload ( self , file : str , folder : str = \".inbox\" , isid : bool = False ) -> requests . Response : \"\"\" Uploads a file to a folder. Args: file: Path to a file to be uploaded folder: Can be either a folder name or ID. isid: Bool when folder is an ID Returns: Upload response \"\"\" if not os . path . exists ( file ): raise FileNotFoundError ( f \"File { file } does not exist.\" ) file_name = os . path . basename ( file ) if self . id ( file_name , \"documents\" ): file_id = self . id ( file_name , \"documents\" ) tools . check_id ( file_id ) else : if isid : folder_id : str = folder else : folder_id = self . id ( folder , \"folders\" ) # type: ignore tools . check_id ( folder_id ) file_id = self . api . nodes . create ( file_name , \"documents\" , folder_id ) url = f \" { self . api . apiurl } /documents/ { file_id } /upload/ { file_name } \" mimetype = guess_type ( file_name )[ 1 ] headers : dict = { \"Content-Disposition\" : f \"attachment; filename= { file_name } \" , \"Content-Type\" : mimetype , \"Authorization\" : f \"Token { self . api . token } \" , } with open ( file , \"rb\" ) as fobj : response = requests . put ( url , data = fobj , headers = headers , timeout = 5 ) return response","title":"Documents"},{"location":"reference/pypapermerge/endpoints/documents/#pypapermerge.endpoints.documents.Documents","text":"Class that implements the document endpoints Source code in pypapermerge/endpoints/documents.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 class Documents : \"\"\" Class that implements the document endpoints \"\"\" def __init__ ( self , api ): # type: ignore self . api = api def all ( self ) -> dict : \"\"\" Returns all documents on the server Returns: return_dict: Key: ID of documents, Value (dict): attributes of documents \"\"\" headers = { \"Authorization\" : f \"Token { self . api . token } \" , } response = requests . get ( f \" { self . api . apiurl } /documents/\" , headers = headers , timeout = 5 ) json_content = json . loads ( response . content ) return_dict = {} for i in json_content [ \"data\" ]: return_dict . update ({ i [ \"id\" ]: i [ \"attributes\" ]}) return return_dict def id ( # pylint: disable=C0103 self , name : str , content_type : str ) -> str | list [ str ] | None : \"\"\" Returns the ID of either documents or folders type Args: name: Name of either a document or folder content_type: Can be one of \"documents\" or \"folders\", based on the type of content to id Returns: None (None): If no fitting document/folder was found return_id (str): If one fitting document/folder was found return_id (list): If multiple fitting documents/folders were found \"\"\" tools . check_ctype ( content_type ) reverse_dict = self . _reverse_list ( content_type ) if name in reverse_dict : logger . trace ( f \"ID of { name } is: { reverse_dict [ name ] } \" ) return_id = reverse_dict [ name ] if len ( return_id ) == 1 : return return_id [ 0 ] return return_id return None def upload ( self , file : str , folder : str = \".inbox\" , isid : bool = False ) -> requests . Response : \"\"\" Uploads a file to a folder. Args: file: Path to a file to be uploaded folder: Can be either a folder name or ID. isid: Bool when folder is an ID Returns: Upload response \"\"\" if not os . path . exists ( file ): raise FileNotFoundError ( f \"File { file } does not exist.\" ) file_name = os . path . basename ( file ) if self . id ( file_name , \"documents\" ): file_id = self . id ( file_name , \"documents\" ) tools . check_id ( file_id ) else : if isid : folder_id : str = folder else : folder_id = self . id ( folder , \"folders\" ) # type: ignore tools . check_id ( folder_id ) file_id = self . api . nodes . create ( file_name , \"documents\" , folder_id ) url = f \" { self . api . apiurl } /documents/ { file_id } /upload/ { file_name } \" mimetype = guess_type ( file_name )[ 1 ] headers : dict = { \"Content-Disposition\" : f \"attachment; filename= { file_name } \" , \"Content-Type\" : mimetype , \"Authorization\" : f \"Token { self . api . token } \" , } with open ( file , \"rb\" ) as fobj : response = requests . put ( url , data = fobj , headers = headers , timeout = 5 ) return response def delete ( self , idd : str ) -> bool : \"\"\" Deletes the document identified by the ID given to the function Arguments: idd: ID of the document to be deleted Returns: Either True or False, based on the success of deletion of the document \"\"\" tools . check_id ( idd ) url = f \" { self . api . apiurl } /documents/ { idd } \" headers : dict = { \"Authorization\" : f \"Token { self . api . token } \" } response = requests . delete ( url , headers = headers , timeout = 5 ) return_code = response . status_code == 204 return return_code def _reverse_list ( self , content_type : str ) -> dict : \"\"\" Returns a reversed list of all documents, in order to find the specific ID of a document if only a name is known \"\"\" tools . check_ctype ( content_type ) headers = { \"Authorization\" : f \"Token { self . api . token } \" , } if content_type == \"documents\" : url = f \" { self . api . apiurl } /documents/\" else : url = f \" { self . api . apiurl } /folders/\" response = requests . get ( url , headers = headers , timeout = 5 ) json_content = json . loads ( response . content ) reverse_dict = defaultdict ( list ) for i in json_content [ \"data\" ]: reverse_dict [ i [ \"attributes\" ][ \"title\" ]] . append ( i [ \"id\" ]) return reverse_dict","title":"Documents"},{"location":"reference/pypapermerge/endpoints/documents/#pypapermerge.endpoints.documents.Documents.all","text":"Returns all documents on the server Returns: Name Type Description return_dict dict Key: ID of documents, Value (dict): attributes of documents Source code in pypapermerge/endpoints/documents.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def all ( self ) -> dict : \"\"\" Returns all documents on the server Returns: return_dict: Key: ID of documents, Value (dict): attributes of documents \"\"\" headers = { \"Authorization\" : f \"Token { self . api . token } \" , } response = requests . get ( f \" { self . api . apiurl } /documents/\" , headers = headers , timeout = 5 ) json_content = json . loads ( response . content ) return_dict = {} for i in json_content [ \"data\" ]: return_dict . update ({ i [ \"id\" ]: i [ \"attributes\" ]}) return return_dict","title":"all()"},{"location":"reference/pypapermerge/endpoints/documents/#pypapermerge.endpoints.documents.Documents.delete","text":"Deletes the document identified by the ID given to the function Parameters: Name Type Description Default idd str ID of the document to be deleted required Returns: Type Description bool Either True or False, based on the success of deletion of the document Source code in pypapermerge/endpoints/documents.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 def delete ( self , idd : str ) -> bool : \"\"\" Deletes the document identified by the ID given to the function Arguments: idd: ID of the document to be deleted Returns: Either True or False, based on the success of deletion of the document \"\"\" tools . check_id ( idd ) url = f \" { self . api . apiurl } /documents/ { idd } \" headers : dict = { \"Authorization\" : f \"Token { self . api . token } \" } response = requests . delete ( url , headers = headers , timeout = 5 ) return_code = response . status_code == 204 return return_code","title":"delete()"},{"location":"reference/pypapermerge/endpoints/documents/#pypapermerge.endpoints.documents.Documents.id","text":"Returns the ID of either documents or folders type Parameters: Name Type Description Default name str Name of either a document or folder required content_type str Can be one of \"documents\" or \"folders\", based on the type of content to id required Returns: Name Type Description None None If no fitting document/folder was found return_id str If one fitting document/folder was found return_id list If multiple fitting documents/folders were found Source code in pypapermerge/endpoints/documents.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def id ( # pylint: disable=C0103 self , name : str , content_type : str ) -> str | list [ str ] | None : \"\"\" Returns the ID of either documents or folders type Args: name: Name of either a document or folder content_type: Can be one of \"documents\" or \"folders\", based on the type of content to id Returns: None (None): If no fitting document/folder was found return_id (str): If one fitting document/folder was found return_id (list): If multiple fitting documents/folders were found \"\"\" tools . check_ctype ( content_type ) reverse_dict = self . _reverse_list ( content_type ) if name in reverse_dict : logger . trace ( f \"ID of { name } is: { reverse_dict [ name ] } \" ) return_id = reverse_dict [ name ] if len ( return_id ) == 1 : return return_id [ 0 ] return return_id return None","title":"id()"},{"location":"reference/pypapermerge/endpoints/documents/#pypapermerge.endpoints.documents.Documents.upload","text":"Uploads a file to a folder. Parameters: Name Type Description Default file str Path to a file to be uploaded required folder str Can be either a folder name or ID. '.inbox' isid bool Bool when folder is an ID False Returns: Type Description requests . Response Upload response Source code in pypapermerge/endpoints/documents.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def upload ( self , file : str , folder : str = \".inbox\" , isid : bool = False ) -> requests . Response : \"\"\" Uploads a file to a folder. Args: file: Path to a file to be uploaded folder: Can be either a folder name or ID. isid: Bool when folder is an ID Returns: Upload response \"\"\" if not os . path . exists ( file ): raise FileNotFoundError ( f \"File { file } does not exist.\" ) file_name = os . path . basename ( file ) if self . id ( file_name , \"documents\" ): file_id = self . id ( file_name , \"documents\" ) tools . check_id ( file_id ) else : if isid : folder_id : str = folder else : folder_id = self . id ( folder , \"folders\" ) # type: ignore tools . check_id ( folder_id ) file_id = self . api . nodes . create ( file_name , \"documents\" , folder_id ) url = f \" { self . api . apiurl } /documents/ { file_id } /upload/ { file_name } \" mimetype = guess_type ( file_name )[ 1 ] headers : dict = { \"Content-Disposition\" : f \"attachment; filename= { file_name } \" , \"Content-Type\" : mimetype , \"Authorization\" : f \"Token { self . api . token } \" , } with open ( file , \"rb\" ) as fobj : response = requests . put ( url , data = fobj , headers = headers , timeout = 5 ) return response","title":"upload()"},{"location":"reference/pypapermerge/endpoints/nodes/","text":"Nodes endpoint API calls Nodes Class that implements the nodes endpoints Source code in pypapermerge/endpoints/nodes.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Nodes : \"\"\" Class that implements the nodes endpoints \"\"\" def __init__ ( self , api ): # type: ignore self . api = api def create ( self , name : str , content_type : str , parent_folder_id : str ) -> str : \"\"\" Creates a node, based on the arguments given. Args: name: Name of node that should be created content_type: Either 'documents' or 'folders' parent_folder_id: ID of the parent folder the node should be created in Returns: node_id: ID of the created node \"\"\" tools . check_ctype ( content_type ) tools . check_id ( parent_folder_id ) headers = { \"Authorization\" : f \"Token { self . api . token } \" , \"Content-Type\" : \"application/vnd.api+json\" , } data = { \"data\" : { \"type\" : content_type , \"attributes\" : { \"title\" : name }, \"relationships\" : { \"parent\" : { \"data\" : { \"type\" : \"folders\" , \"id\" : parent_folder_id }} }, } } response = requests . post ( f \" { self . api . apiurl } /nodes/\" , headers = headers , json = data , timeout = 5 ) logger . trace ( f \"nodes.create response is: { response } \" ) node_id = json . loads ( response . content )[ \"data\" ][ \"id\" ] return node_id create ( name , content_type , parent_folder_id ) Creates a node, based on the arguments given. Parameters: Name Type Description Default name str Name of node that should be created required content_type str Either 'documents' or 'folders' required parent_folder_id str ID of the parent folder the node should be created in required Returns: Name Type Description node_id str ID of the created node Source code in pypapermerge/endpoints/nodes.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def create ( self , name : str , content_type : str , parent_folder_id : str ) -> str : \"\"\" Creates a node, based on the arguments given. Args: name: Name of node that should be created content_type: Either 'documents' or 'folders' parent_folder_id: ID of the parent folder the node should be created in Returns: node_id: ID of the created node \"\"\" tools . check_ctype ( content_type ) tools . check_id ( parent_folder_id ) headers = { \"Authorization\" : f \"Token { self . api . token } \" , \"Content-Type\" : \"application/vnd.api+json\" , } data = { \"data\" : { \"type\" : content_type , \"attributes\" : { \"title\" : name }, \"relationships\" : { \"parent\" : { \"data\" : { \"type\" : \"folders\" , \"id\" : parent_folder_id }} }, } } response = requests . post ( f \" { self . api . apiurl } /nodes/\" , headers = headers , json = data , timeout = 5 ) logger . trace ( f \"nodes.create response is: { response } \" ) node_id = json . loads ( response . content )[ \"data\" ][ \"id\" ] return node_id","title":"Nodes"},{"location":"reference/pypapermerge/endpoints/nodes/#pypapermerge.endpoints.nodes.Nodes","text":"Class that implements the nodes endpoints Source code in pypapermerge/endpoints/nodes.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Nodes : \"\"\" Class that implements the nodes endpoints \"\"\" def __init__ ( self , api ): # type: ignore self . api = api def create ( self , name : str , content_type : str , parent_folder_id : str ) -> str : \"\"\" Creates a node, based on the arguments given. Args: name: Name of node that should be created content_type: Either 'documents' or 'folders' parent_folder_id: ID of the parent folder the node should be created in Returns: node_id: ID of the created node \"\"\" tools . check_ctype ( content_type ) tools . check_id ( parent_folder_id ) headers = { \"Authorization\" : f \"Token { self . api . token } \" , \"Content-Type\" : \"application/vnd.api+json\" , } data = { \"data\" : { \"type\" : content_type , \"attributes\" : { \"title\" : name }, \"relationships\" : { \"parent\" : { \"data\" : { \"type\" : \"folders\" , \"id\" : parent_folder_id }} }, } } response = requests . post ( f \" { self . api . apiurl } /nodes/\" , headers = headers , json = data , timeout = 5 ) logger . trace ( f \"nodes.create response is: { response } \" ) node_id = json . loads ( response . content )[ \"data\" ][ \"id\" ] return node_id","title":"Nodes"},{"location":"reference/pypapermerge/endpoints/nodes/#pypapermerge.endpoints.nodes.Nodes.create","text":"Creates a node, based on the arguments given. Parameters: Name Type Description Default name str Name of node that should be created required content_type str Either 'documents' or 'folders' required parent_folder_id str ID of the parent folder the node should be created in required Returns: Name Type Description node_id str ID of the created node Source code in pypapermerge/endpoints/nodes.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def create ( self , name : str , content_type : str , parent_folder_id : str ) -> str : \"\"\" Creates a node, based on the arguments given. Args: name: Name of node that should be created content_type: Either 'documents' or 'folders' parent_folder_id: ID of the parent folder the node should be created in Returns: node_id: ID of the created node \"\"\" tools . check_ctype ( content_type ) tools . check_id ( parent_folder_id ) headers = { \"Authorization\" : f \"Token { self . api . token } \" , \"Content-Type\" : \"application/vnd.api+json\" , } data = { \"data\" : { \"type\" : content_type , \"attributes\" : { \"title\" : name }, \"relationships\" : { \"parent\" : { \"data\" : { \"type\" : \"folders\" , \"id\" : parent_folder_id }} }, } } response = requests . post ( f \" { self . api . apiurl } /nodes/\" , headers = headers , json = data , timeout = 5 ) logger . trace ( f \"nodes.create response is: { response } \" ) node_id = json . loads ( response . content )[ \"data\" ][ \"id\" ] return node_id","title":"create()"}]}